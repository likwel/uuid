const randomUUID = (e = null) => { let t = e && null != e.delimiter ? e.delimiter : "-", r = e && null != e.format ? e.format : "8-4-4-4-12", n = e && e.version ? e.version : 4; if (r = r.replaceAll("-", t), null == r) return "xxxxxxxx-xxxx-" + n + "xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function (e) { const t = 16 * Math.random() | 0; return ("x" == e ? t : 3 & t | 8).toString(16) })); return r.split(t).map((e => parseInt(e, 10))).map(((e, t) => { if (2 === t) return n + randomHex(e - 1); if (3 === t) { return (3 & Math.floor(16 * Math.random()) | 8).toString(16) + randomHex(e - 1) } return randomHex(e) })).join(t) }, UUID = (e, t = null) => { let r = t && null != t.delimiter ? t.delimiter : "-", n = t && null != t.format ? t.format : "8-4-4-4-12", l = t && t.version ? t.version : 4; n = n.replaceAll("-", r); parseBigInt(e, 6).toString(16); let o = encrypt(e, { delimiter: r }); if (e || null != n) { if (e && null == n) return "xxxxxxxx-xxxx-" + l + "xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function (t) { const r = 16 * seededRandom(e) | 0; e++; return ("x" == t ? r : 3 & r | 8).toString(16) })); { const t = n.split(r).map((e => parseInt(e, 10))); let x = "", i = e; return t.forEach(((e, t) => { for (let r = 0; r < e; r++) { let e; if (2 === t && 0 === r) e = l; else if (3 === t && 0 === r) { const t = 16 * seededRandom(i) | 0; i++, e = (3 & t | 8).toString(16) } else { const t = 16 * seededRandom(i) | 0; i++, e = t.toString(16) } x += e } x += r })), { uuid: x.slice(0, -1), encryped: o } } } return randomUUID() }, randomHex = e => { let t = ""; for (let r = 0; r < e; r++)t += Math.floor(16 * Math.random()).toString(16); return t }; function seededRandom(e) { var t = 1e4 * Math.sin(e); return t - Math.floor(t) } function parseBigInt(e, t = 10) { if ("string" == typeof e) { if ("number" != typeof t || isNaN(t) || t < 2 || t > 36) throw new Error(`parseBigInt doesn't support base ${t}`); let r = 0n; t = BigInt(t); for (const n of e) r *= t, r += BigInt(parseInt(n, 6)); return r } return BigInt(e) } const parseInteger = e => parseInt(e, 16), encrypt = (e, t = null) => { let r = t && t.key ? t.key : "0dcb1e721df31294ba751c6363617bbf", n = t && null != t.delimiter ? t.delimiter : "-", l = t && null != t.divided_to ? t.divided_to : 4; e = e.toString(); let o = ""; for (let t = 0; t < e.length; t++) { o += ("0" + (e.charCodeAt(t) ^ r.charCodeAt(t % r.length)).toString(16)).slice(-2) } let x = ""; for (let e = 0; e < o.length; e += l)x += o.substr(e, l) + n; return x = x.slice(0, -1), x }, decrypt = (e, t = null) => { let r = t && t.key ? t.key : "0dcb1e721df31294ba751c6363617bbf", n = t && null != t.delimiter ? t.delimiter : "-"; e = e.replaceAll(n, ""); let l = ""; for (let t = 0; t < e.length; t += 2) { let n = e.substr(t, 2), o = parseInt(n, 16) ^ r.charCodeAt(t / 2 % r.length); l += String.fromCharCode(o) } return l };